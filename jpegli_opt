import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
from tkinterdnd2 import DND_FILES, TkinterDnD
import subprocess
import os
import shutil
from pathlib import Path
from PIL import Image
import threading
import cv2
import numpy as np

# --- HELPER FUNCTIONS ---
def predict_safe_distance(stats):
    """Predict optimal Butteraugli distance based on image characteristics"""
    edge = stats["edge_density"]
    texture = stats["texture"]
    variance = stats["variance"]
    noise = stats["noise"]

    distance = 0.65

    # Texture masking
    if texture > 18:
        distance += 0.5
    elif texture > 10:
        distance += 0.25

    # Noise masking
    if noise > 8:
        distance += 0.4
    elif noise > 4:
        distance += 0.2

    # Flat areas
    if variance < 250:
        distance -= 0.35
    elif variance < 600:
        distance -= 0.15

    # Low-texture smooth photos
    if texture < 6 and variance < 800:
        distance -= 0.2

    # Text detection
    text_score = edge / max(texture, 1.0)
    if text_score > 0.018:
        distance -= 0.25
    elif text_score > 0.012:
        distance -= 0.15

    # General edge safety
    if edge > 0.08:
        distance -= 0.1

    # Ultra-flat hard cap
    if variance < 180:
        distance = min(distance, 0.8)

    return max(0.65, min(distance, 2.2))

def analyze_image_fast(image_path, max_size=512):
    """Fast perceptual analysis for image characteristics"""
    img = Image.open(image_path).convert("RGB")

    # Downscale for performance
    w, h = img.size
    scale = min(max_size / max(w, h), 1.0)
    if scale < 1.0:
        img = img.resize((int(w * scale), int(h * scale)), Image.BICUBIC)

    img_np = np.array(img)
    gray = cv2.cvtColor(img_np, cv2.COLOR_RGB2GRAY)

    # Edge detection
    edges = cv2.Canny(gray, 80, 160)
    edge_density = edges.mean()

    # Texture/detail
    lap = cv2.Laplacian(gray, cv2.CV_64F)
    texture = np.mean(np.abs(lap))

    # Flatness
    variance = gray.var()

    # Noise estimation
    noise = np.median(np.abs(gray - cv2.GaussianBlur(gray, (3, 3), 0)))

    return {
        "edge_density": edge_density,
        "texture": texture,
        "variance": variance,
        "noise": noise
    }


# --- MAIN CLASS ---

class JPEGLIOptimizer:
    def __init__(self, root):
        self.root = root
        self.root.title("JPEGLI Image Optimizer")
        self.root.geometry("550x600")
        
        # Style configuration
        style = ttk.Style()
        style.theme_use('xpnative')
        
        # Make sliders thicker
        style.configure('Horizontal.TScale', sliderlength=20, sliderthickness=15)
        
        # Paths
        script_dir = Path(__file__).parent
        self.cjpegli_path = script_dir / "jxl" / "cjpegli.exe"
        self.exiftool_path = script_dir / "exiftool.exe"
        
        # Variables
        self.quality = tk.IntVar(value=94)
        self.max_width = tk.IntVar(value=2000)
        self.enable_resize = tk.BooleanVar(value=False)
        self.auto_quality = tk.BooleanVar(value=True)
        self.min_reduction = tk.IntVar(value=15)
        self.enable_min_reduction = tk.BooleanVar(value=False)
        self.processing = False
        
        # Validate tools on startup
        self.validate_tools()
        self.setup_ui()
        
    def validate_tools(self):
        """Validate that required tools exist before allowing processing"""
        errors = []
        
        if not self.cjpegli_path.exists():
            errors.append(f"cjpegli.exe not found at:\n{self.cjpegli_path}")
        
        if not self.exiftool_path.exists():
            errors.append(f"exiftool.exe not found at:\n{self.exiftool_path}")
        
        if errors:
            error_msg = "\n\n".join(errors)
            error_msg += "\n\nMetadata preservation is mandatory. Please ensure all required tools are present."
            messagebox.showerror("Missing Required Tools", error_msg)
            self.root.quit()
            raise SystemExit("Required tools not found")
        
    def setup_ui(self):
        # Title
        title_label = tk.Label(
            self.root, 
            text="JPEGLI Optimizer", 
            font=("Arial", 13, "bold")
        )
        title_label.pack(pady=8)
        
        # Settings Frame
        settings_frame = ttk.LabelFrame(self.root, text="Settings", padding=10)
        settings_frame.pack(fill="x", padx=10, pady=5)
        
        # Auto quality mode
        auto_frame = ttk.Frame(settings_frame)
        auto_frame.pack(fill="x", pady=5)
        ttk.Checkbutton(
            auto_frame, 
            text="Auto-optimize quality", 
            variable=self.auto_quality,
            command=self.toggle_quality_mode
        ).pack(side="left")
        
        # Quality slider frame (manual mode only)
        self.quality_frame = ttk.Frame(settings_frame)
        ttk.Label(self.quality_frame, text="Quality:").pack(side="left")
        quality_slider = ttk.Scale(
            self.quality_frame, 
            from_=60, 
            to=100, 
            variable=self.quality, 
            orient="horizontal", 
            length=150
        )
        quality_slider.pack(side="left", padx=10)
        self.quality_value = ttk.Label(self.quality_frame, text="94", width=4)
        self.quality_value.pack(side="left")
        
        quality_slider.config(command=lambda val: self.quality_value.config(text=f"{int(float(val))}"))
        
        # Resize options
        resize_frame = ttk.Frame(settings_frame)
        resize_frame.pack(fill="x", pady=5)
        ttk.Checkbutton(
            resize_frame, 
            text="Resize to max width:", 
            variable=self.enable_resize
        ).pack(side="left")
        ttk.Entry(resize_frame, textvariable=self.max_width, width=8).pack(side="left", padx=5)
        ttk.Label(resize_frame, text="px").pack(side="left")
        
        # Minimum reduction threshold
        reduction_frame = ttk.Frame(settings_frame)
        reduction_frame.pack(fill="x", pady=5)
        ttk.Checkbutton(
            reduction_frame, 
            text="Only replace if reduction â‰¥", 
            variable=self.enable_min_reduction
        ).pack(side="left")
        reduction_slider = ttk.Scale(
            reduction_frame, 
            from_=5, 
            to=50, 
            variable=self.min_reduction, 
            orient="horizontal", 
            length=100
        )
        reduction_slider.pack(side="left", padx=10)
        self.reduction_value = ttk.Label(reduction_frame, text="15%", width=5)
        self.reduction_value.pack(side="left")
        
        reduction_slider.config(command=lambda val: self.reduction_value.config(text=f"{int(float(val))}%"))
        
        # Initial toggle
        self.toggle_quality_mode()
        
        # Drop zone
        drop_frame = ttk.LabelFrame(self.root, padding=5)
        drop_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
        self.drop_label = tk.Label(
            drop_frame, 
            text="Drag and drop JPG/JPEG images here\n\nðŸ“‚",
            font=("Arial", 12),
            bg="#f0f0f0",
            relief="solid",
            borderwidth=1
        )
        self.drop_label.pack(fill="both", expand=True)
        
        # Register drop target
        self.drop_label.drop_target_register(DND_FILES)
        self.drop_label.dnd_bind('<<Drop>>', self.on_drop)
        
        # Progress
        progress_frame = ttk.Frame(self.root)
        progress_frame.pack(fill="x", padx=10, pady=5)
        
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(
            progress_frame, 
            variable=self.progress_var, 
            maximum=100
        )
        self.progress_bar.pack(fill="x")
        
        # Log area
        log_frame = ttk.LabelFrame(self.root, text="Log", padding=5)
        log_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
        self.log_text = scrolledtext.ScrolledText(
            log_frame, 
            height=8, 
            state="disabled", 
            wrap="word"
        )
        self.log_text.pack(fill="both", expand=True)
        
    def toggle_quality_mode(self):
        """Toggle between auto and manual quality mode"""
        if self.auto_quality.get():
            self.quality_frame.pack_forget()
        else:
            self.quality_frame.pack(fill="x", pady=5)
        
    def log(self, message):
        """Thread-safe logging to text widget"""
        self.log_text.config(state="normal")
        self.log_text.insert("end", f"{message}\n")
        self.log_text.see("end")
        self.log_text.config(state="disabled")
        self.root.update_idletasks()
        
    def on_drop(self, event):
        """Handle drag and drop event"""
        if self.processing:
            messagebox.showwarning("Processing", "Please wait for current batch to complete")
            return
            
        files = self.root.tk.splitlist(event.data)
        image_files = [f for f in files if f.lower().endswith(('.jpg', '.jpeg'))]
        
        if not image_files:
            messagebox.showwarning("No Images", "No JPG/JPEG files found in dropped items")
            return
        
        # Process in separate thread
        thread = threading.Thread(target=self.process_images, args=(image_files,))
        thread.daemon = True
        thread.start()
        
    def extract_metadata(self, file_path):
        """Extract metadata using ExifTool - MANDATORY"""
        metadata_file = file_path.with_suffix('.metadata.jpg')
        
        try:
            shutil.copy2(file_path, metadata_file)
            return metadata_file
        except Exception as e:
            raise Exception(f"Failed to backup metadata: {e}")
        
    def restore_metadata(self, file_path, metadata_file):
        """Restore metadata using ExifTool - MANDATORY"""
        if not metadata_file or not metadata_file.exists():
            raise Exception("Metadata backup file not found")
            
        try:
            cmd = [
                str(self.exiftool_path),
                '-tagsfromfile', str(metadata_file),
                '-all:all',
                '-overwrite_original',
                str(file_path)
            ]
            
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            
            if result.returncode != 0:
                raise Exception(f"ExifTool failed: {result.stderr}")
            
            self.log(f"  âœ“ Metadata preserved (EXIF/IPTC/XMP)")
            metadata_file.unlink()
            
        except Exception as e:
            raise Exception(f"Failed to restore metadata: {e}")
        finally:
            # Cleanup
            if metadata_file and metadata_file.exists():
                try:
                    metadata_file.unlink()
                except:
                    pass

    def process_images(self, files):
        """Process batch of images"""
        self.processing = True
        self.progress_var.set(0)
        
        total = len(files)
        self.log(f"Starting batch processing of {total} images...")
        
        stats = {
            'total_original_size': 0,
            'total_new_size': 0,
            'processed': 0,
            'skipped': 0,
            'errors': 0
        }
        
        for idx, file_path in enumerate(files):
            try:
                result = self.process_single_image(file_path)
                if result:
                    stats['total_original_size'] += result['original_size']
                    stats['total_new_size'] += result['new_size']
                    if result['replaced']:
                        stats['processed'] += 1
                    else:
                        stats['skipped'] += 1
            except Exception as e:
                stats['errors'] += 1
                self.log(f"âœ— ERROR processing {os.path.basename(file_path)}: {str(e)}")
            
            self.progress_var.set(((idx + 1) / total) * 100)
        
        # Summary
        self.print_summary(stats, total)
        self.processing = False
    
    def print_summary(self, stats, total):
        """Print batch processing summary"""
        self.log(f"\n{'='*60}")
        self.log(f"BATCH SUMMARY:")
        self.log(f"  Total images: {total}")
        self.log(f"  âœ“ Processed: {stats['processed']}")
        self.log(f"  âŠ˜ Skipped: {stats['skipped']}")
        self.log(f"  âœ— Errors: {stats['errors']}")
        
        if stats['total_original_size'] > 0:
            reduction_pct = ((stats['total_original_size'] - stats['total_new_size']) / 
                           stats['total_original_size']) * 100
            saved_mb = (stats['total_original_size'] - stats['total_new_size']) / (1024 * 1024)
            
            self.log(f"  Original: {stats['total_original_size']/(1024*1024):.2f} MB")
            self.log(f"  New size: {stats['total_new_size']/(1024*1024):.2f} MB")
            self.log(f"  Saved: {saved_mb:.2f} MB ({reduction_pct:.1f}% reduction)")
        
        self.log(f"{'='*60}\n")
    
    def process_single_image(self, file_path):
        """Process a single image with mandatory metadata preservation"""
        file_path = Path(file_path)
        self.log(f"\nProcessing: {file_path.name}")
        
        # Get original file stats
        original_size = file_path.stat().st_size
        original_mtime = file_path.stat().st_mtime
        original_atime = file_path.stat().st_atime
        
        # MANDATORY metadata extraction
        try:
            metadata_file = self.extract_metadata(file_path)
        except Exception as e:
            raise Exception(f"Cannot proceed without metadata backup: {e}")
        
        temp_file = file_path.with_suffix('.tmp.jpg')
        
        try:
            # Analyze image
            stats = analyze_image_fast(file_path)
            text_score = stats["edge_density"] / max(stats["texture"], 1.0)
            chroma = "444" if text_score > 0.015 else "420"
            
            # Handle resize
            source_file = self.handle_resize(file_path, stats)
            
            # Build cjpegli command
            cmd = self.build_cjpegli_command(source_file, temp_file, stats, chroma)
            
            # Execute
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            if result.returncode != 0:
                raise Exception(f"cjpegli failed: {result.stderr}")
            
            # Cleanup resize temp
            if source_file != file_path and source_file.exists():
                source_file.unlink()
            
            # Check if optimization is worthwhile
            new_size = temp_file.stat().st_size
            reduction = ((original_size - new_size) / original_size) * 100
            
            if not self.should_replace(reduction, original_size, new_size):
                temp_file.unlink()
                metadata_file.unlink()
                return {
                    'original_size': original_size,
                    'new_size': original_size,
                    'replaced': False
                }
            
            # Replace original
            shutil.move(str(temp_file), str(file_path))
            
            # MANDATORY metadata restoration
            try:
                self.restore_metadata(file_path, metadata_file)
            except Exception as e:
                raise Exception(f"Failed to restore metadata (file corrupted): {e}")
            
            # Restore timestamps
            os.utime(file_path, (original_atime, original_mtime))
            
            self.log(f"  {original_size:,} â†’ {new_size:,} bytes ({reduction:.1f}% reduction)")
            
            return {
                'original_size': original_size,
                'new_size': new_size,
                'replaced': True
            }
            
        except Exception as e:
            # Cleanup on error
            if temp_file.exists():
                temp_file.unlink()
            if metadata_file and metadata_file.exists():
                metadata_file.unlink()
            raise
    
    def handle_resize(self, file_path, stats):
        """Handle image resizing if enabled"""
        if not self.enable_resize.get():
            return file_path
        
        img = Image.open(file_path)
        width, height = img.size
        max_dim = max(width, height)
        
        if max_dim > self.max_width.get():
            ratio = self.max_width.get() / max_dim
            new_width = int(width * ratio)
            new_height = int(height * ratio)
            img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
            resized_temp = file_path.with_suffix('.resized.jpg')
            img.save(resized_temp, 'JPEG', quality=99)
            self.log(f"  Resized: {width}x{height} â†’ {new_width}x{new_height}")
            return resized_temp
        
        return file_path
    
    def build_cjpegli_command(self, source_file, temp_file, stats, chroma):
        """Build cjpegli command based on settings"""
        cmd = [str(self.cjpegli_path), str(source_file), str(temp_file)]
        
        if self.auto_quality.get():
            predicted_distance = predict_safe_distance(stats)
            self.log(f"  Auto distance: {predicted_distance:.2f} "
                    f"(edge={stats['edge_density']:.3f}, "
                    f"tex={stats['texture']:.1f}, "
                    f"var={stats['variance']:.0f})")
            cmd.extend([
                f"--distance={predicted_distance}",
                f"--chroma_subsampling={chroma}",
                "--progressive_level=2"
            ])
        else:
            self.log(f"  Manual quality: {self.quality.get()}")
            cmd.append(f"--quality={self.quality.get()}")
        
        return cmd
    
    def should_replace(self, reduction, original_size, new_size):
        """Determine if optimized file should replace original"""
        if reduction <= 0:
            self.log(f"  âŠ˜ Skipped: No optimization possible")
            return False
        
        if self.enable_min_reduction.get() and reduction < self.min_reduction.get():
            self.log(f"  âŠ˜ Skipped: {reduction:.1f}% < {self.min_reduction.get()}% threshold")
            return False
        
        return True

if __name__ == "__main__":
    root = TkinterDnD.Tk()
    app = JPEGLIOptimizer(root)
    root.mainloop()
