import tkinter as tk
from tkinter import ttk, scrolledtext, messagebox
from tkinterdnd2 import DND_FILES, TkinterDnD
import subprocess
import os
import shutil
from pathlib import Path
from PIL import Image
import threading
import cv2
import numpy as np

# --- HELPER FUNCTIONS ---
def predict_safe_distance(stats):
    """
    Predict optimal Butteraugli distance using Fluid Linear Logic.
    Refined for ~49-50% reduction (High Quality).
    """
    edge = stats["edge_density"]
    texture = stats["texture"]
    variance = stats["variance"]
    noise = stats["noise"]

    # --- 1. THE BASELINE ---
    # Lowered from 0.65 to 0.62.
    # This adds roughly 3-5% to the file size across the board for extra safety.
    distance = 0.62

    # --- 2. DYNAMIC TEXTURE BONUS (Linear) ---
    # Increased threshold from 5.0 to 6.0.
    # Now, images must be "properly textured" before we compress them more.
    if texture > 6.0:
        # Slope remains 0.02
        tex_bonus = (texture - 6.0) * 0.02
        # Cap remains 0.40
        distance += min(tex_bonus, 0.40)

    # --- 3. EDGE BRAKING ---
    # (Face/Text Saver)
    if edge > 0.10:
        brake = (edge - 0.10) * 2.6
        distance -= brake

    # --- 4. NOISE & SKY SAFETY ---
    if noise > 6.0:
        distance += 0.05
    
    # Gradient protection
    if variance < 800:
        distance -= 0.05

    # --- 5. HARD BOUNDARIES ---
    # Min 0.62 (Very high quality)
    # Max 1.0 (Safe limit)
    return max(0.62, min(distance, 1.0))

def analyze_image_fast(image_path, max_size=None):
    """Full resolution analysis using OpenCV directly."""
    try:
        # Load image stream directly to numpy array (Fastest method)
        # 0 flag loads as Grayscale directly
        stream = open(image_path, "rb")
        bytes_data = bytearray(stream.read())
        numpy_array = np.asarray(bytes_data, dtype=np.uint8)
        stream.close()
        
        gray = cv2.imdecode(numpy_array, 0) # 0 = CV_LOAD_IMAGE_GRAYSCALE
        
        if gray is None:
            raise Exception("Image decode failed")

    except Exception as e:
        # Fallback
        img = Image.open(image_path).convert("L")
        gray = np.array(img)

    # 1. Edge Detection
    # Thresholds adjusted for full resolution natural photography
    edges = cv2.Canny(gray, 50, 150)
    edge_density = np.mean(edges) / 255.0

    # 2. Texture/Detail
    lap = cv2.Laplacian(gray, cv2.CV_64F)
    texture = np.mean(np.abs(lap))

    # 3. Variance (Flatness)
    variance = np.var(gray)

    # 4. Noise Estimation (Center Crop Strategy)
    # Analyzing full 24MP+ noise is slow, so we take a large center sample
    h, w = gray.shape
    sample_size = 2048
    if h > sample_size and w > sample_size:
        y, x = (h - sample_size)//2, (w - sample_size)//2
        crop = gray[y:y+sample_size, x:x+sample_size]
    else:
        crop = gray
        
    noise = np.median(np.abs(crop - cv2.GaussianBlur(crop, (3, 3), 0)))

    return {
        "edge_density": edge_density,
        "texture": texture,
        "variance": variance,
        "noise": noise
    }

# --- MAIN CLASS ---

class JPEGLIOptimizer:
    def __init__(self, root):
        self.root = root
        self.root.title("JPEGLI Image Optimizer")
        self.root.geometry("550x600")
                
        # Style configuration
        style = ttk.Style()
        style.theme_use('xpnative')
        
        # Make sliders thicker
        style.configure('Horizontal.TScale', sliderlength=20, sliderthickness=15)
        
        # Paths
        script_dir = Path(__file__).parent
        self.cjpegli_path = script_dir / "jxl" / "cjpegli.exe"
        self.exiftool_path = script_dir / "exiftool.exe"
        
        # Variables
        self.quality = tk.IntVar(value=94)
        self.max_width = tk.IntVar(value=2000)
        self.enable_resize = tk.BooleanVar(value=False)
        self.auto_quality = tk.BooleanVar(value=True)
        self.min_reduction = tk.IntVar(value=15)
        self.enable_min_reduction = tk.BooleanVar(value=False)
        self.processing = False
        
        # Validate tools on startup
        self.validate_tools()
        self.setup_ui()
        
    def validate_tools(self):
        """Validate that required tools exist before allowing processing"""
        errors = []
        
        if not self.cjpegli_path.exists():
            errors.append(f"cjpegli.exe not found at:\n{self.cjpegli_path}")
        
        if not self.exiftool_path.exists():
            errors.append(f"exiftool.exe not found at:\n{self.exiftool_path}")
        
        if errors:
            error_msg = "\n\n".join(errors)
            error_msg += "\n\nMetadata preservation is mandatory. Please ensure all required tools are present."
            messagebox.showerror("Missing Required Tools", error_msg)
            self.root.quit()
            raise SystemExit("Required tools not found")
        
    def setup_ui(self):
        # Title
        title_label = tk.Label(
            self.root, 
            text="JPEGLI Optimizer", 
            font=("Arial", 13, "bold")
        )
        title_label.pack(pady=8)
        
        # Settings Frame
        settings_frame = ttk.LabelFrame(self.root, text="Settings", padding=10)
        settings_frame.pack(fill="x", padx=10, pady=5)
        
        # Auto quality mode
        auto_frame = ttk.Frame(settings_frame)
        auto_frame.pack(fill="x", pady=5)
        ttk.Checkbutton(
            auto_frame, 
            text="Auto-optimize quality", 
            variable=self.auto_quality,
            command=self.toggle_quality_mode
        ).pack(side="left")
        
        # Quality slider frame (manual mode only)
        self.quality_frame = ttk.Frame(settings_frame)
        ttk.Label(self.quality_frame, text="Quality:").pack(side="left")
        quality_slider = ttk.Scale(
            self.quality_frame, 
            from_=60, 
            to=100, 
            variable=self.quality, 
            orient="horizontal", 
            length=150
        )
        quality_slider.pack(side="left", padx=10)
        self.quality_value = ttk.Label(self.quality_frame, text="94", width=4)
        self.quality_value.pack(side="left")
        
        quality_slider.config(command=lambda val: self.quality_value.config(text=f"{int(float(val))}"))
        
        # Resize options
        resize_frame = ttk.Frame(settings_frame)
        resize_frame.pack(fill="x", pady=5)
        ttk.Checkbutton(
            resize_frame, 
            text="Resize to max width:", 
            variable=self.enable_resize
        ).pack(side="left")
        ttk.Entry(resize_frame, textvariable=self.max_width, width=8).pack(side="left", padx=5)
        ttk.Label(resize_frame, text="px").pack(side="left")
        
        # Minimum reduction threshold
        reduction_frame = ttk.Frame(settings_frame)
        reduction_frame.pack(fill="x", pady=5)
        ttk.Checkbutton(
            reduction_frame, 
            text="Only replace if reduction â‰¥", 
            variable=self.enable_min_reduction
        ).pack(side="left")
        reduction_slider = ttk.Scale(
            reduction_frame, 
            from_=5, 
            to=50, 
            variable=self.min_reduction, 
            orient="horizontal", 
            length=100
        )
        reduction_slider.pack(side="left", padx=10)
        self.reduction_value = ttk.Label(reduction_frame, text="15%", width=5)
        self.reduction_value.pack(side="left")
        
        reduction_slider.config(command=lambda val: self.reduction_value.config(text=f"{int(float(val))}%"))
        
        # Initial toggle
        self.toggle_quality_mode()
        
        # Drop zone
        drop_frame = ttk.LabelFrame(self.root, padding=5)
        drop_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
        self.drop_label = tk.Label(
            drop_frame, 
            text="Drag and drop JPG/JPEG images here\n\nðŸ“‚",
            font=("Arial", 12),
            bg="#f0f0f0",
            relief="solid",
            borderwidth=1
        )
        self.drop_label.pack(fill="both", expand=True)
        
        # Register drop target
        self.drop_label.drop_target_register(DND_FILES)
        self.drop_label.dnd_bind('<<Drop>>', self.on_drop)
        
        # Progress
        progress_frame = ttk.Frame(self.root)
        progress_frame.pack(fill="x", padx=10, pady=5)
        
        self.progress_var = tk.DoubleVar()
        self.progress_bar = ttk.Progressbar(
            progress_frame, 
            variable=self.progress_var, 
            maximum=100
        )
        self.progress_bar.pack(fill="x")
        
        # Log area
        log_frame = ttk.LabelFrame(self.root, text="Log", padding=5)
        log_frame.pack(fill="both", expand=True, padx=10, pady=5)
        
        self.log_text = scrolledtext.ScrolledText(
            log_frame, 
            height=8, 
            state="disabled", 
            wrap="word"
        )
        self.log_text.pack(fill="both", expand=True)
        
    def toggle_quality_mode(self):
        """Toggle between auto and manual quality mode"""
        if self.auto_quality.get():
            self.quality_frame.pack_forget()
        else:
            self.quality_frame.pack(fill="x", pady=5)
        
    def log(self, message):
        """Thread-safe logging to text widget"""
        self.log_text.config(state="normal")
        self.log_text.insert("end", f"{message}\n")
        self.log_text.see("end")
        self.log_text.config(state="disabled")
        self.root.update_idletasks()
        
    def on_drop(self, event):
        """Handle drag and drop event"""
        if self.processing:
            messagebox.showwarning("Processing", "Please wait for current batch to complete")
            return
            
        files = self.root.tk.splitlist(event.data)
        image_files = [f for f in files if f.lower().endswith(('.jpg', '.jpeg'))]
        
        if not image_files:
            messagebox.showwarning("No Images", "No JPG/JPEG files found in dropped items")
            return
        
        # Process in separate thread
        thread = threading.Thread(target=self.process_images, args=(image_files,))
        thread.daemon = True
        thread.start()
        
    def extract_metadata(self, file_path):
        """Extract metadata using ExifTool - MANDATORY"""
        metadata_file = file_path.with_suffix('.metadata.jpg')
        
        try:
            shutil.copy2(file_path, metadata_file)
            return metadata_file
        except Exception as e:
            raise Exception(f"Failed to backup metadata: {e}")
        
    def restore_metadata(self, file_path, metadata_file):
        """Restore metadata using ExifTool - MANDATORY"""
        if not metadata_file or not metadata_file.exists():
            raise Exception("Metadata backup file not found")
            
        try:
            cmd = [
                str(self.exiftool_path),
                '-charset', 'filename=UTF8'
                '-tagsfromfile', str(metadata_file),
                '-all:all',
                '-overwrite_original',
                str(file_path)
            ]
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
            if result.returncode != 0:
                raise Exception(f"ExifTool failed: {result.stderr}")
            metadata_file.unlink()
            
        except Exception as e:
            raise Exception(f"Failed to restore metadata: {e}")
        finally:
            # Cleanup
            if metadata_file and metadata_file.exists():
                try:
                    metadata_file.unlink()
                except:
                    pass

    def process_images(self, files):
        """Process batch of images"""
        self.processing = True
        self.progress_var.set(0)
        
        total = len(files)
        self.log(f"Starting batch processing of {total} images...")
        
        stats = {
            'total_original_size': 0,
            'total_new_size': 0,
            'processed': 0,
            'skipped': 0,
            'errors': 0
        }
        
        for idx, file_path in enumerate(files):
            try:
                result = self.process_single_image(file_path)
                if result:
                    stats['total_original_size'] += result['original_size']
                    stats['total_new_size'] += result['new_size']
                    if result['replaced']:
                        stats['processed'] += 1
                    else:
                        stats['skipped'] += 1
            except Exception as e:
                stats['errors'] += 1
                self.log(f"âœ— ERROR processing {os.path.basename(file_path)}: {str(e)}")
            
            self.progress_var.set(((idx + 1) / total) * 100)
        
        # Summary
        self.print_summary(stats, total)
        self.processing = False
    
    def print_summary(self, stats, total):
        """Print batch processing summary"""
        self.log(f"\n{'='*60}")
        self.log(f"BATCH SUMMARY:")
        self.log(f"  Total images: {total}")
        self.log(f"  âœ“ Processed: {stats['processed']}")
        self.log(f"  âŠ˜ Skipped: {stats['skipped']}")
        self.log(f"  âœ— Errors: {stats['errors']}")
        
        if stats['total_original_size'] > 0:
            reduction_pct = ((stats['total_original_size'] - stats['total_new_size']) / 
                           stats['total_original_size']) * 100
            saved_mb = (stats['total_original_size'] - stats['total_new_size']) / (1024 * 1024)
            
            self.log(f"  Original: {stats['total_original_size']/(1024*1024):.2f} MB")
            self.log(f"  New size: {stats['total_new_size']/(1024*1024):.2f} MB")
            self.log(f"  Saved: {saved_mb:.2f} MB ({reduction_pct:.1f}% reduction)")
        
        self.log(f"{'='*60}\n")
    
    def process_single_image(self, file_path):
        """Process a single image with mandatory metadata preservation"""
        file_path = Path(file_path)
        self.log(f"\nProcessing: {file_path.name}")
        
        # Get original file stats
        original_size = file_path.stat().st_size
        original_mtime = file_path.stat().st_mtime
        original_atime = file_path.stat().st_atime
        
        # Metadata extraction
        try:
            metadata_file = self.extract_metadata(file_path)
        except Exception as e:
            raise Exception(f"Cannot proceed without metadata backup: {e}")
        
        temp_file = file_path.with_suffix('.tmp.jpg')
        
        try:
            # Analyze image
            stats = analyze_image_fast(file_path)
            text_score = stats["edge_density"] / max(stats["texture"], 1.0)
            chroma = "444" if text_score > 0.015 else "420"
            
            # Handle resize
            source_file = self.handle_resize(file_path, stats)
            
            # Build cjpegli command
            cmd = self.build_cjpegli_command(source_file, temp_file, stats, chroma)
            
            # Execute
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
            if result.returncode != 0:
                raise Exception(f"cjpegli failed: {result.stderr}")
            
            # Cleanup resize temp
            if source_file != file_path and source_file.exists():
                source_file.unlink()
            
            # Check if optimization is worthwhile
            new_size = temp_file.stat().st_size
            reduction = ((original_size - new_size) / original_size) * 100
            
            if not self.should_replace(reduction, original_size, new_size):
                temp_file.unlink()
                metadata_file.unlink()
                return {
                    'original_size': original_size,
                    'new_size': original_size,
                    'replaced': False
                }
            
            # Replace original
            shutil.move(str(temp_file), str(file_path))
            
            # MANDATORY metadata restoration
            try:
                self.restore_metadata(file_path, metadata_file)
            except Exception as e:
                raise Exception(f"Failed to restore metadata (file corrupted): {e}")
            
            # Restore timestamps
            os.utime(file_path, (original_atime, original_mtime))
            
            self.log(f"  {original_size:,} â†’ {new_size:,} bytes ({reduction:.1f}% reduction)")
            
            return {
                'original_size': original_size,
                'new_size': new_size,
                'replaced': True
            }
            
        except Exception as e:
            # Cleanup on error
            if temp_file.exists():
                temp_file.unlink()
            if metadata_file and metadata_file.exists():
                metadata_file.unlink()
            raise
    
    def handle_resize(self, file_path, stats):
        """Handle image resizing if enabled"""
        if not self.enable_resize.get():
            return file_path
        
        img = Image.open(file_path)
        width, height = img.size
        max_dim = max(width, height)
        
        if max_dim > self.max_width.get():
            ratio = self.max_width.get() / max_dim
            new_width = int(width * ratio)
            new_height = int(height * ratio)
            img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
            resized_temp = file_path.with_suffix('.resized.jpg')
            img.save(resized_temp, 'JPEG', quality=99)
            self.log(f"  Resized: {width}x{height} â†’ {new_width}x{new_height}")
            return resized_temp
        
        return file_path
    
    def build_cjpegli_command(self, source_file, temp_file, stats, chroma):
        """Build cjpegli command based on settings"""
        cmd = [str(self.cjpegli_path), str(source_file), str(temp_file)]
        
        if self.auto_quality.get():
            predicted_distance = predict_safe_distance(stats)
            self.log(f"  Auto distance: {predicted_distance:.2f} "
                    f"(edge={stats['edge_density']:.3f}, "
                    f"tex={stats['texture']:.1f}, "
                    f"var={stats['variance']:.0f})")
            cmd.extend([
                f"--distance={predicted_distance}",
                f"--chroma_subsampling={chroma}",
                "--progressive_level=2"
            ])
        else:
            self.log(f"  Manual quality: {self.quality.get()}")
            cmd.append(f"--quality={self.quality.get()}")
        
        return cmd
    
    def should_replace(self, reduction, original_size, new_size):
        """Determine if optimized file should replace original"""
        if reduction <= 0:
            self.log(f"  âŠ˜ Skipped: No optimization possible")
            return False
        
        # Always enforce minimum 5% reduction
        min_threshold = self.min_reduction.get() if self.enable_min_reduction.get() else 10
        
        if reduction < min_threshold:
            self.log(f"  âŠ˜ Skipped: {reduction:.1f}% < {min_threshold}% threshold")
            return False
        
        return True

if __name__ == "__main__":
    root = TkinterDnD.Tk()
    app = JPEGLIOptimizer(root)
    root.mainloop()
